<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Fastapi中使用后台任务</title>
      <link href="//posts/KHWV2F.html"/>
      <url>//posts/KHWV2F.html</url>
      
        <content type="html"><![CDATA[<p>之前在项目中使用是异步非阻塞方式处理线程任务，但是一段时间之后云服务监控提示出现异常，猜测应该是出现了资源阻塞。重新查看fastapi官方文档发现，fastapi其实提供了一个<a href="https://fastapi.tiangolo.com/tutorial/background-tasks/">BackgroundTasks</a>的后台任务。</p><p>那么就记录一下吧~</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI, BackgroundTasks</span><br><span class="line"><span class="keyword">from</span> starlette.requests <span class="keyword">import</span> Request</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取请求IP</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_client_ip</span>(<span class="params">request: Request</span>):</span></span><br><span class="line">    headers = <span class="built_in">dict</span>(request.headers)</span><br><span class="line">    ip = headers.get(<span class="string">&#x27;x-forwarded-for&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> ip    </span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取请求IP归属地，根据自身需求选择免费还是付费的接口调用，得到IP归属地后更新DB表</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">update_user_ip_area</span>(<span class="params">ip, userId</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.post(<span class="params"><span class="string">&#x27;/test&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">test_api</span>(<span class="params">*, req: Request, background_task: BackgroundTasks</span>):</span></span><br><span class="line">    ip = get_client_ip(req)</span><br><span class="line">    background_task.add_task(update_user_ip_area, ip, userId)</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&#x27;code&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;msg&#x27;</span>: <span class="string">&#x27;success&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><ul><li>在使用时必须在路径方法中导入并并定义一个参数，声明其类型为BackgroundTasks。</li><li>后台任务方法可以是<code>async def</code>函数，也可以是<code>def</code>函数，这并不影响函数的执行调用。</li><li>如果需要执行的是一个繁重的计算且可能需要多个进程运行（如不需要共享内存、变量等），使用其他更大的工具（Celery），他们的效果可能会更好。</li><li>它们往往需要更复杂的配置、消息/作业队列管理器（RabbitMQ或Redis），但她们允许在多个进程中运行后台任务，尤其是在多服务器中。</li><li>如果需要从同一个Fastapi应用程序访问变量和对象，或者需要执行小型后台任务，可以简单地使用BackgroundTasks。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fastapi中使用异步非阻塞</title>
      <link href="//posts/YWGUF.html"/>
      <url>//posts/YWGUF.html</url>
      
        <content type="html"><![CDATA[<p>原项目前后端不分离，拆分重构为前后端分离。原来的后端框架用的是flask，多重考虑之下选择了Fastapi这个异步框架。然后在重构过程中发现了一个比较尴尬的问题，flask下在一些接口中使用了线程去处理入库数据。</p><p>同时还有鉴于8月的新规（《互联网用户账号信息管理规定》），结合业务需求，需要记录并显示用户的IP归属地。没办法，只能研究了下Fastapi中异步非阻塞的实现方法。</p><p>以获取用户IP归属地为例</p><h2 id="关键代码"><a href="#关键代码" class="headerlink" title="关键代码"></a>关键代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"><span class="keyword">from</span> starlette.requests <span class="keyword">import</span> Request</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个专门处理事件循环的函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">start_loop</span>(<span class="params">loop</span>):</span></span><br><span class="line">    asyncio.set_event_loop(loop)</span><br><span class="line">    loop.run_forever()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取请求IP</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_client_ip</span>(<span class="params">request: Request</span>):</span></span><br><span class="line">    headers = <span class="built_in">dict</span>(request.headers)</span><br><span class="line">    ip = headers.get(<span class="string">&#x27;x-forwarded-for&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> ip    </span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取请求IP归属地，根据自身需求选择免费还是付费的接口调用，得到IP归属地后更新DB表</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">update_user_ip_area</span>(<span class="params">ip, userId</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.post(<span class="params"><span class="string">&#x27;/test&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">test_api</span>(<span class="params">*, req: Request</span>):</span></span><br><span class="line">    ip = get_client_ip(req)</span><br><span class="line">    coroutine1 = update_user_ip_area(ip, userId)</span><br><span class="line">    new_loop = asyncio.new_event_loop()</span><br><span class="line">    t = threading.Thread(target=start_loop, args=(new_loop,))</span><br><span class="line">    t.start()</span><br><span class="line">    _run = asyncio.run_coroutine_threadsafe(coroutine1, new_loop)</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&#x27;code&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;msg&#x27;</span>: <span class="string">&#x27;success&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><ul><li>需要注意Fastapi的接口是靠协程来完成的，如果在部署的时候分配给程序的资源不够，就很容易造成资源堵塞，特别是在并发的场景下。</li><li>选择用户比较关键且触发请求较少的接口来完成该功能。</li><li>若是需要在请求比较频繁的接口中使用，可以对IP进行缓存，当IP不同时再触发该逻辑，这样也可以减少IP归属地接口的请求。  </li></ul>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python进程、线程、协程的区别</title>
      <link href="//posts/ASDHGW.html"/>
      <url>//posts/ASDHGW.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、进程、线程、协程定义"><a href="#一、进程、线程、协程定义" class="headerlink" title="一、进程、线程、协程定义"></a>一、进程、线程、协程定义</h1><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>进程是具有一定独立功能的程序关于某个数据集上的一次运行活动，是有系统进行资源分配和调度的一个独立单位。每个进程都有独立的内存空间，不同进程减通过进程间通信来完成通信。开销（栈、寄存器、虚拟内存、文件句柄等）大，但相对稳定安全。</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>线程是进程的一个执行单元，是CPU调度和分派的基本单位，是比进程更小的能独立运行的基本单位。一个进程可以有多个线程，这些线程共享这个进程的全部资源。线程间通信主要通过共享内存。但是由于GIL存在，一个单核CPU在时间点上只能有一个线程执行。</p><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p>协程，又称微线程，纤程。Coroutine<br>协程是Python中另一种实现多任务的方式，比线程占用更少的资源。协程自带CPU上下文，可以在协程之间切换，只要这个过程中保存或恢复CPU上下文那么程序还是可以运行的。<br>在一个线程中的某个函数，可以在任何地方保存当前函数的一些临时变量等信息，然后切换到另一个函数中执行，注意不是通过调用函数的方式做到的，并且切换的次数以及什么时候再切换到原来的函数都是由开发者自己决定。</p><h1 id="二、进程、线程、协程区别"><a href="#二、进程、线程、协程区别" class="headerlink" title="二、进程、线程、协程区别"></a>二、进程、线程、协程区别</h1><ul><li><p>进程与线程</p><ul><li>地址空间：县城是进程内的一个执行单元，进程内至少有一个线程，每个线程共享该进程的地址空间，而进程有自己独立的地址空间。</li><li>资源拥有：进程是自愿分配和拥有的单位，同一个进程内的线程共享进程的资源。</li><li>线程是CPU调度的基本单位，但进程不是。</li><li>二者均可并发执行</li></ul></li><li><p>协程与线程</p><ul><li>一个线程可以有多个协程，一个进程也可以单独拥有多个协程，这样在Python中就可以使用多核CPU。</li><li>线程进程都是同步机制，而协程则是异步。</li><li>协程能保留上一次调用时的状态，每次过程重入时，就相当于进入上一次调用的状态。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>免费常用IP归属地查询接口</title>
      <link href="//posts/WERGAS.html"/>
      <url>//posts/WERGAS.html</url>
      
        <content type="html"><![CDATA[<h1 id="IP-API接口"><a href="#IP-API接口" class="headerlink" title="IP-API接口"></a>IP-API接口</h1><p>文档： <a href="http://ip.taobao.com/instructions">http://ip.taobao.com/instructions</a></p><p>请求示例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">api_url = <span class="string">&#x27;http://ip.taobao.com/outGetIpInfo?ip=218.18.45.7&amp;accessKey=alibaba-inc&#x27;</span></span><br><span class="line">result = requests.get(api_url)</span><br><span class="line">res_json = result.json()</span><br><span class="line"></span><br><span class="line">res_json:</span><br><span class="line">&#123;</span><br><span class="line">    data: &#123;</span><br><span class="line">        area: <span class="string">&quot;&quot;</span>,</span><br><span class="line">        country: <span class="string">&quot;中国&quot;</span>,</span><br><span class="line">        isp_id: <span class="string">&quot;100017&quot;</span>,</span><br><span class="line">        queryIp: <span class="string">&quot;218.18.45.7&quot;</span>,</span><br><span class="line">        city: <span class="string">&quot;深圳&quot;</span>,</span><br><span class="line">        ip: <span class="string">&quot;218.18.45.7&quot;</span>,</span><br><span class="line">        isp: <span class="string">&quot;电信&quot;</span>,</span><br><span class="line">        county: <span class="string">&quot;&quot;</span>,</span><br><span class="line">        region_id: <span class="string">&quot;440000&quot;</span>,</span><br><span class="line">        area_id: <span class="string">&quot;&quot;</span>,</span><br><span class="line">        county_id: null,</span><br><span class="line">        region: <span class="string">&quot;广东&quot;</span>,</span><br><span class="line">        country_id: <span class="string">&quot;CN&quot;</span>,</span><br><span class="line">        city_id: <span class="string">&quot;440300&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    msg: <span class="string">&quot;query success&quot;</span>,</span><br><span class="line">    code: <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="IP-API接口-1"><a href="#IP-API接口-1" class="headerlink" title="IP-API接口"></a>IP-API接口</h1><p>文档： <a href="https://ip-api.com/docs/api:json">https://ip-api.com/docs/api:json</a></p><p>请求示例：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">api_url = <span class="string">&#x27;http://ip-api.com/json/218.18.45.7?lang=zh-CN&#x27;</span></span><br><span class="line">result = requests.get(api_url)</span><br><span class="line">res_json = result.json()</span><br><span class="line"></span><br><span class="line">res_json:</span><br><span class="line">&#123;</span><br><span class="line">    status: <span class="string">&quot;success&quot;</span>,</span><br><span class="line">    country: <span class="string">&quot;中国&quot;</span>,</span><br><span class="line">    countryCode: <span class="string">&quot;CN&quot;</span>,</span><br><span class="line">    region: <span class="string">&quot;GD&quot;</span>,</span><br><span class="line">    regionName: <span class="string">&quot;广东&quot;</span>,</span><br><span class="line">    city: <span class="string">&quot;深圳&quot;</span>,</span><br><span class="line">    <span class="built_in">zip</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    lat: <span class="number">22.5559</span>,</span><br><span class="line">    lon: <span class="number">114.0577</span>,</span><br><span class="line">    timezone: <span class="string">&quot;Asia/Shanghai&quot;</span>,</span><br><span class="line">    isp: <span class="string">&quot;CHINANET Guangdong province Shenzhen MAN network&quot;</span>,</span><br><span class="line">    org: <span class="string">&quot;Chinanet GD&quot;</span>,</span><br><span class="line">    <span class="keyword">as</span>: <span class="string">&quot;AS134774 CHINANET Guangdong province Shenzhen MAN network&quot;</span>,</span><br><span class="line">    query: <span class="string">&quot;218.18.45.7&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="太平洋IP"><a href="#太平洋IP" class="headerlink" title="太平洋IP"></a>太平洋IP</h1><p>文档：<a href="http://whois.pconline.com.cn/">http://whois.pconline.com.cn/</a></p><p>请求示例：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">api_url = <span class="string">&#x27;http://whois.pconline.com.cn/ipJson.jsp?ip=218.18.45.7&amp;json=true&#x27;</span></span><br><span class="line">result = requests.get(api_url)</span><br><span class="line">res_json = result.json()</span><br><span class="line"></span><br><span class="line">res_json:</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;ip&quot;</span>:<span class="string">&quot;218.18.45.7&quot;</span>,</span><br><span class="line">    <span class="string">&quot;pro&quot;</span>:<span class="string">&quot;广东省&quot;</span>,</span><br><span class="line">    <span class="string">&quot;proCode&quot;</span>:<span class="string">&quot;440000&quot;</span>,</span><br><span class="line">    <span class="string">&quot;city&quot;</span>:<span class="string">&quot;深圳市&quot;</span>,</span><br><span class="line">    <span class="string">&quot;cityCode&quot;</span>:<span class="string">&quot;440300&quot;</span>,</span><br><span class="line">    <span class="string">&quot;region&quot;</span>:<span class="string">&quot;南山区&quot;</span>,</span><br><span class="line">    <span class="string">&quot;regionCode&quot;</span>:<span class="string">&quot;440305&quot;</span>,</span><br><span class="line">    <span class="string">&quot;addr&quot;</span>:<span class="string">&quot;广东省深圳市南山区 电信ADSL&quot;</span>,</span><br><span class="line">    <span class="string">&quot;regionNames&quot;</span>:<span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="string">&quot;err&quot;</span>:<span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="useragentinfo"><a href="#useragentinfo" class="headerlink" title="useragentinfo"></a>useragentinfo</h1><p>文档： <a href="https://ip.useragentinfo.com/">https://ip.useragentinfo.com/</a></p><p>请求示例：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">api_url = <span class="string">&#x27;https://ip.useragentinfo.com/json?ip=218.18.45.7&#x27;</span></span><br><span class="line">result = requests.get(api_url)</span><br><span class="line">res_json = result.json()</span><br><span class="line"></span><br><span class="line">res_json:</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;country&quot;</span>:<span class="string">&quot;中国&quot;</span>,</span><br><span class="line">    <span class="string">&quot;short_name&quot;</span>:<span class="string">&quot;CN&quot;</span>,</span><br><span class="line">    <span class="string">&quot;province&quot;</span>:<span class="string">&quot;广东省&quot;</span>,</span><br><span class="line">    <span class="string">&quot;city&quot;</span>:<span class="string">&quot;深圳市&quot;</span>,</span><br><span class="line">    <span class="string">&quot;area&quot;</span>:<span class="string">&quot;南山区&quot;</span>,</span><br><span class="line">    <span class="string">&quot;isp&quot;</span>:<span class="string">&quot;电信&quot;</span>,</span><br><span class="line">    <span class="string">&quot;net&quot;</span>:<span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="string">&quot;ip&quot;</span>:<span class="string">&quot;218.18.45.7&quot;</span>,</span><br><span class="line">    <span class="string">&quot;code&quot;</span>:<span class="number">200</span>,</span><br><span class="line">    <span class="string">&quot;desc&quot;</span>:<span class="string">&quot;success&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="说在最后"><a href="#说在最后" class="headerlink" title="说在最后"></a>说在最后</h1><p>免费接口学习使用就好，至于业务需求，俗话说得好：能用钱解决的问题都不是问题~</p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中间件 </tag>
            
            <tag> Python </tag>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac环境下为brew切换为国内源</title>
      <link href="//posts/HAFI23.html"/>
      <url>//posts/HAFI23.html</url>
      
        <content type="html"><![CDATA[<h1 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h1><p>今天尝试使用代码给视频文件中添加音频文件时一直失败，查了资料后发现是缺了一个依赖，而brew默认官方源是国外，国内访问难免会慢到人神共愤（当然如果你有TZ当我没说），所以找了下如何切换国内源的方法。</p><h1 id="查看当前配置"><a href="#查看当前配置" class="headerlink" title="查看当前配置"></a>查看当前配置</h1><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看 brew.git 当前源</span></span><br><span class="line">$ <span class="built_in">cd</span> <span class="string">&quot;<span class="subst">$(brew --repo)</span>&quot;</span> &amp;&amp; git remote -v</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 homebrew-core.git 当前源</span></span><br><span class="line">$ <span class="built_in">cd</span> <span class="string">&quot;<span class="subst">$(brew --repo homebrew/core)</span>&quot;</span> &amp;&amp; git remote -v</span><br></pre></td></tr></table></figure><h1 id="清华源"><a href="#清华源" class="headerlink" title="清华源"></a>清华源</h1><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 替换各个源</span></span><br><span class="line">$ git -C <span class="string">&quot;<span class="subst">$(brew --repo)</span>&quot;</span> remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/brew.git</span><br><span class="line">$ git -C <span class="string">&quot;<span class="subst">$(brew --repo homebrew/core)</span>&quot;</span> remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-core.git</span><br><span class="line">$ git -C <span class="string">&quot;<span class="subst">$(brew --repo homebrew/cask)</span>&quot;</span> remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-cask.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># zsh 替换 brew bintray 镜像</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles&#x27;</span> &gt;&gt; ~/.zshrc</span><br><span class="line">$ <span class="built_in">source</span> ~/.zshrc</span><br><span class="line"></span><br><span class="line"><span class="comment"># bash 替换 brew bintray 镜像</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles&#x27;</span> &gt;&gt; ~/.bash_profile</span><br><span class="line">$ <span class="built_in">source</span> ~/.bash_profile</span><br><span class="line"></span><br><span class="line"><span class="comment"># 刷新源</span></span><br><span class="line">$ brew update</span><br></pre></td></tr></table></figure><h1 id="阿里源"><a href="#阿里源" class="headerlink" title="阿里源"></a>阿里源</h1><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看 brew.git 当前源</span></span><br><span class="line">$ <span class="built_in">cd</span> <span class="string">&quot;<span class="subst">$(brew --repo)</span>&quot;</span> &amp;&amp; git remote -v</span><br><span class="line">origin    https://github.com/Homebrew/brew.git (fetch)</span><br><span class="line">origin    https://github.com/Homebrew/brew.git (push)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 homebrew-core.git 当前源</span></span><br><span class="line">$ <span class="built_in">cd</span> <span class="string">&quot;<span class="subst">$(brew --repo homebrew/core)</span>&quot;</span> &amp;&amp; git remote -v</span><br><span class="line">origin    https://github.com/Homebrew/homebrew-core.git (fetch)</span><br><span class="line">origin    https://github.com/Homebrew/homebrew-core.git (push)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改 brew.git 为阿里源</span></span><br><span class="line">$ git -C <span class="string">&quot;<span class="subst">$(brew --repo)</span>&quot;</span> remote set-url origin https://mirrors.aliyun.com/homebrew/brew.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改 homebrew-core.git 为阿里源</span></span><br><span class="line">$ git -C <span class="string">&quot;<span class="subst">$(brew --repo homebrew/core)</span>&quot;</span> remote set-url origin https://mirrors.aliyun.com/homebrew/homebrew-core.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># zsh 替换 brew bintray 镜像</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.aliyun.com/homebrew/homebrew-bottles&#x27;</span> &gt;&gt; ~/.zshrc</span><br><span class="line">$ <span class="built_in">source</span> ~/.zshrc</span><br><span class="line"></span><br><span class="line"><span class="comment"># bash 替换 brew bintray 镜像</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.aliyun.com/homebrew/homebrew-bottles&#x27;</span> &gt;&gt; ~/.bash_profile</span><br><span class="line">$ <span class="built_in">source</span> ~/.bash_profile</span><br><span class="line"></span><br><span class="line"><span class="comment"># 刷新源</span></span><br><span class="line">$ brew update</span><br></pre></td></tr></table></figure><h1 id="中科大源"><a href="#中科大源" class="headerlink" title="中科大源"></a>中科大源</h1><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 替换各个源</span></span><br><span class="line">$ git -C <span class="string">&quot;<span class="subst">$(brew --repo)</span>&quot;</span> remote set-url origin https://mirrors.ustc.edu.cn/brew.git</span><br><span class="line">$ git -C <span class="string">&quot;<span class="subst">$(brew --repo homebrew/core)</span>&quot;</span> remote set-url origin https://mirrors.ustc.edu.cn/homebrew-core.git</span><br><span class="line">$ git -C <span class="string">&quot;<span class="subst">$(brew --repo homebrew/cask)</span>&quot;</span> remote set-url origin https://mirrors.ustc.edu.cn/homebrew-cask.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># zsh 替换 brew bintray 镜像</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.ustc.edu.cn/homebrew-bottles&#x27;</span> &gt;&gt; ~/.zshrc</span><br><span class="line">$ <span class="built_in">source</span> ~/.zshrc</span><br><span class="line"></span><br><span class="line"><span class="comment"># bash 替换 brew bintray 镜像</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.ustc.edu.cn/homebrew-bottles&#x27;</span> &gt;&gt; ~/.bash_profile</span><br><span class="line">$ <span class="built_in">source</span> ~/.bash_profile</span><br><span class="line"></span><br><span class="line"><span class="comment"># 刷新源</span></span><br><span class="line">$ brew update</span><br></pre></td></tr></table></figure><h1 id="重置为官方源"><a href="#重置为官方源" class="headerlink" title="重置为官方源"></a>重置为官方源</h1><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 重置 brew.git 为官方源</span></span><br><span class="line">$ git -C <span class="string">&quot;<span class="subst">$(brew --repo)</span>&quot;</span> remote set-url origin https://github.com/Homebrew/brew.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重置 homebrew-core.git 为官方源</span></span><br><span class="line">$ git -C <span class="string">&quot;<span class="subst">$(brew --repo homebrew/core)</span>&quot;</span> remote set-url origin https://github.com/Homebrew/homebrew-core.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重置 homebrew-cask.git 为官方源</span></span><br><span class="line">$ git -C <span class="string">&quot;<span class="subst">$(brew --repo homebrew/cask)</span>&quot;</span> remote set-url origin https://github.com/Homebrew/homebrew-cask</span><br><span class="line"></span><br><span class="line"><span class="comment"># zsh 注释掉 HOMEBREW_BOTTLE_DOMAIN 配置</span></span><br><span class="line">$ vi ~/.zshrc</span><br><span class="line"><span class="comment"># export HOMEBREW_BOTTLE_DOMAIN=xxxxxxxxx</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># bash 注释掉 HOMEBREW_BOTTLE_DOMAIN 配置</span></span><br><span class="line">$ vi ~/.bash_profile</span><br><span class="line"><span class="comment"># export HOMEBREW_BOTTLE_DOMAIN=xxxxxxxxx</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 刷新源</span></span><br><span class="line">$ brew update</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MAC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统查看端口占用及结束进程方法</title>
      <link href="//posts/EWTVRW.html"/>
      <url>//posts/EWTVRW.html</url>
      
        <content type="html"><![CDATA[<p>本地开发程序时经常会碰到端口占用的情况，这个时候就需要使用命令查看并将占用的进程杀掉。以下是不同操作系统的不同查询方式。<br>示例：<br>    查询端口4000的占用情况，占用进程PID为1375</p><h1 id="Mac-Linux环境"><a href="#Mac-Linux环境" class="headerlink" title="Mac/Linux环境"></a>Mac/Linux环境</h1><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看端口4000的占用情况</span></span><br><span class="line">sudo losf -i :4000</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据占用的PID来结束进程</span></span><br><span class="line">sudo <span class="built_in">kill</span> -9 1375</span><br></pre></td></tr></table></figure><h1 id="Windows环境"><a href="#Windows环境" class="headerlink" title="Windows环境"></a>Windows环境</h1><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">netstat -aon|findstr <span class="string">&quot;4000&quot;</span></span><br></pre></td></tr></table></figure><p>结束进程<br>1.使用命令<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">taskkill /T /F /PID 1375</span><br></pre></td></tr></table></figure><br>2.使用任务管理器来结束进程</p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MAC </tag>
            
            <tag> Linux </tag>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang自动导包配置</title>
      <link href="//posts/SVW34F.html"/>
      <url>//posts/SVW34F.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Go开发者所使用的IDE中无非vs code和Goland两种。近期有golang的开发需求，所以找了下关于golang的相关使用及配置。</p><p>以下仅限对代码编辑器的配置，golang的安装还有环境配置不在本次探讨中。</p><h1 id="vscode中配置golang"><a href="#vscode中配置golang" class="headerlink" title="vscode中配置golang"></a>vscode中配置golang</h1><p>vs code是一款由微软开发的跨平台的免费编辑器。该软件支持语法高亮、代码自动补全、代码重构功能，并且内置了命令行工具和Git版本控制系统。</p><h2 id="安装go插件和工具包"><a href="#安装go插件和工具包" class="headerlink" title="安装go插件和工具包"></a>安装go插件和工具包</h2><h3 id="扩展工具中安装GO插件"><a href="#扩展工具中安装GO插件" class="headerlink" title="扩展工具中安装GO插件"></a>扩展工具中安装GO插件</h3><p><img src="https://cdn.jsdelivr.net/gh/konsh/CDN/img/vscode-go插件.png" alt="vscode安装Go插件"></p><h3 id="安装GO工具包"><a href="#安装GO工具包" class="headerlink" title="安装GO工具包"></a>安装GO工具包</h3><p>打开控制面板输入<code>go:install/update tools</code>，勾选全部插件进行安装。</p><blockquote><p>打开控制面板的方法</p><ol><li>查看 - 命令面板</li><li>mac系统可使用快捷键command+shift+P</li><li>win系统可使用快捷键ctrl+shift+P</li></ol></blockquote><p><img src="https://cdn.jsdelivr.net/gh/konsh/CDN/img/vscode-go工具包安装1.png" alt="vscode-go工具包安装1"></p><p><img src="https://cdn.jsdelivr.net/gh/konsh/CDN/img/vscode-go工具包安装2.png" alt="vscode-go工具包安装2"></p><h3 id="更新配置文件"><a href="#更新配置文件" class="headerlink" title="更新配置文件"></a>更新配置文件</h3><p>在 Preferences/首选项 -&gt; Setting/设置 然后输入 go，然后选择 setting.json，填入你想要修改的配置<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;go.autocompleteUnimportedPackages&quot;: true,</span><br><span class="line">&quot;gopls&quot;: &#123;</span><br><span class="line">    &quot;experimentalWorkspaceModule&quot;: true</span><br><span class="line">&#125;,</span><br><span class="line">&quot;go.inferGopath&quot;: true,</span><br><span class="line">&quot;go.toolsManagement.autoUpdate&quot;: true,</span><br><span class="line">&quot;go.gotoSymbol.includeImports&quot;: true,</span><br><span class="line">&quot;go.useCodeSnippetsOnFunctionSuggest&quot;: true,</span><br><span class="line">&quot;go.useCodeSnippetsOnFunctionSuggestWithoutType&quot;: true,</span><br></pre></td></tr></table></figure></p><h1 id="Goland中配置golang"><a href="#Goland中配置golang" class="headerlink" title="Goland中配置golang"></a>Goland中配置golang</h1><p>Preferences -&gt; Go -&gt; Go Modules配置参数<br><img src="https://cdn.jsdelivr.net/gh/konsh/CDN/img/goland-1.png" alt="Goland setting"></p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vs code </tag>
            
            <tag> Golang </tag>
            
            <tag> Goland </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用boto3向AWS S3上传文件</title>
      <link href="//posts/IBUER35.html"/>
      <url>//posts/IBUER35.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Boto3是AWS官方提供的基于python3的开发工具包，Boto3 可以支持您轻松将 Python 应用程序、库或脚本与 AWS 服务进行集成，包括 Amazon S3、Amazon EC2 和 Amazon DynamoDB 等。</p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">pip install boto3</span><br></pre></td></tr></table></figure><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> boto3.session <span class="keyword">import</span> Session</span><br><span class="line"></span><br><span class="line">session = Session(aws_access_key_id=you_id, aws_secret_access_key=you_key)</span><br><span class="line">s3_client = session.client(<span class="string">&#x27;s3&#x27;</span>)</span><br><span class="line">bucket_name = <span class="string">&#x27;you_bucket&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="上传本地文件"><a href="#上传本地文件" class="headerlink" title="上传本地文件"></a>上传本地文件</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">file_path = <span class="string">&quot;本地文件地址&quot;</span></span><br><span class="line">fname = <span class="string">&quot;图片名称&quot;</span></span><br><span class="line">s3_client.upload_file(Filename=file_path, Bucket=bucket_name, key=fname)</span><br></pre></td></tr></table></figure><h2 id="上传二进制文件"><a href="#上传二进制文件" class="headerlink" title="上传二进制文件"></a>上传二进制文件</h2><p>在实际开发api接口实现文件上传功能时，无法使用上面的上传本地文件逻辑，原因是api接口中数据是以文件流的形式传递，所以需要采用二进制数据上传。以下是flask框架为例：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> request</span><br><span class="line"></span><br><span class="line">_file = request.files.get(<span class="string">&#x27;file&#x27;</span>)</span><br><span class="line">s3_client.upload_fileobj(Fileobj=_file.stream, Bucket=bucket_name, Key=fname)</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> AWS </tag>
            
            <tag> 上传文件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python连接Redis集群的方法</title>
      <link href="//posts/AHUG74.html"/>
      <url>//posts/AHUG74.html</url>
      
        <content type="html"><![CDATA[<p>版本说明：</p><ul><li>python 3.8</li><li>redis 3.5.3</li><li>redis-py-cluster 2.1.3</li></ul><h1 id="连接主从-哨兵模式"><a href="#连接主从-哨兵模式" class="headerlink" title="连接主从/哨兵模式"></a>连接主从/哨兵模式</h1><p>安装依赖<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">pip install redis==3.5.3</span><br></pre></td></tr></table></figure></p><p>python示例<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"></span><br><span class="line">conn_pool = redis.ConnectionPool(host=HOST, port=PORT, password=AUTH, db=db)</span><br><span class="line">client = redis.Redis(connection_pool=conn_pool)</span><br></pre></td></tr></table></figure></p><h1 id="连接Cluster集群模式"><a href="#连接Cluster集群模式" class="headerlink" title="连接Cluster集群模式"></a>连接Cluster集群模式</h1><p>安装依赖<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">pip install redis-py-cluster==2.1.3</span><br></pre></td></tr></table></figure></p><p>python示例<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rediscluster <span class="keyword">import</span> RedisCluster</span><br><span class="line"></span><br><span class="line">client = RedisCluster(startup_nodes=[&#123;<span class="string">&#x27;host&#x27;</span>: HOST, <span class="string">&#x27;port&#x27;</span>: PORT&#125;], password=AUTH, decode_responses=<span class="literal">True</span>, skip_full_coverage_check=<span class="literal">True</span>) <span class="comment"># 若是连接不成功，则追加参数ssl=True</span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Databas </tag>
            
            <tag> Redis </tag>
            
            <tag> 中间件 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis的三种集群模式</title>
      <link href="//posts/ESFS7D.html"/>
      <url>//posts/ESFS7D.html</url>
      
        <content type="html"><![CDATA[<p>Redis的三种集群模式</p><ul><li>主从模式</li><li>Sentinel（哨兵）模式</li><li>Cluster集群</li></ul><h1 id="主从模式"><a href="#主从模式" class="headerlink" title="主从模式"></a>主从模式</h1><p><img src="https://cdn.jsdelivr.net/gh/konsh/CDN/img/redis-1.png" alt="redis主从模式"></p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ul><li>通过持久化功能，Redis保证了在服务器重启的情况下也不会丢失（或少量丢失）数据，因为持久化会把内存中数据保存到硬盘上，重启会从硬盘上加载数据。 但是由于数据是存储在一台服务器上的，如果这台服务器出现硬盘故障等问题，也会导致数据丢失。</li><li>为了避免单点故障，通常的做法是将数据库复制多个副本以部署在不同的服务器上，这样即使有一台服务器出现故障，其他服务器依然可以继续提供服务。为此， <strong>Redis 提供了复制（replication）功能，可以实现当一台数据库中的数据更新后，自动将更新的数据同步到其他数据库上</strong>。</li><li>在复制的概念中，数据库分为两类，一类是主数据库（master），另一类是从数据库(slave）。主数据库可以进行读写操作，当写操作导致数据变化时会自动将数据同步给从数据库。而从<strong>数据库一般是只读的，并接受主数据库同步过来的数据</strong>。一个主数据库可以拥有多个从数据库，而一个从数据库只能拥有一个主数据库。</li></ul><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><img src="https://cdn.jsdelivr.net/gh/konsh/CDN/img/redis-2.png" alt="主从原理模式"></p><ul><li>从数据库连接主数据库，发送SYNC命令； </li><li>主数据库接收到SYNC命令后，开始执行BGSAVE命令生成RDB文件并使用缓冲区记录此后执行的所有写命令；</li><li>主数据库BGSAVE执行完后，向所有从数据库发送快照文件，并在发送期间继续记录被执行的写命令； </li><li>从数据库收到快照文件后丢弃所有旧数据，载入收到的快照； </li><li>主数据库快照发送完毕后开始向从数据库发送缓冲区中的写命令； </li><li>从数据库完成对快照的载入，开始接收命令请求，并执行来自主数据库缓冲区的写命令；（<strong>从数据库初始化完成</strong>）</li><li>主数据库每执行一个写命令就会向从数据库发送相同的写命令，从数据库接收并执行收到的写命令；（<strong>从数据库初始化完成后的操作</strong>）</li><li>出现断开重连后，2.8之后的版本会将断线期间的命令传给重数据库，增量复制；</li><li>主从刚刚连接的时候，进行全量同步；全同步结束后，进行增量同步。当然，如果有需要，slave 在任何时候都可以发起全量同步。Redis 的策略是，无论如何，首先会尝试进行增量同步，如不成功，要求从机进行全量同步。</li></ul><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li>支持主从复制，主机会自动将数据同步到从机，可以进行读写分离；</li><li>为了分载Master的读操作压力，Slave服务器可以为客户端提供只读操作的服务，写服务仍然必须由Master来完成；</li><li>Slave同样可以接受其它Slaves的连接和同步请求，这样可以有效的分载Master的同步压力；</li><li>Master Server是以非阻塞的方式为Slaves提供服务。所以在Master-Slave同步期间，客户端仍然可以提交查询或修改请求；</li><li>Slave Server同样是以非阻塞的方式完成数据同步。在同步期间，如果有客户端提交查询请求，Redis则返回同步之前的数据；</li></ul><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul><li>Redis不具备自动容错和恢复功能，主机从机的宕机都会导致前端部分读写请求失败，需要等待机器重启或者手动切换才能恢复（<strong>即需要人工介入</strong>）；</li><li>主机宕机，宕机前有部分数据未能及时同步到从机，切换IP后还会引入数据不一致的问题，降低了系统的可用性；</li><li>如果多个Slave断线了，需要重启的时候，尽量不要在同一时间段进行重启。因为只要Slave启动，就会发送sync请求和主机全量同步，当多个 Slave 重启的时候，可能会导致 Master IO剧增从而宕机；</li><li>Redis较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂；</li></ul><h1 id="Sentinel（哨兵）模式"><a href="#Sentinel（哨兵）模式" class="headerlink" title="Sentinel（哨兵）模式"></a>Sentinel（哨兵）模式</h1><p>哨兵模式是一种特殊的模式，首先Redis提供了哨兵的命令，哨兵是一个独立的进程，作为进程，它会独立运行。其原理是哨兵通过发送命令，等待Redis服务器响应，从而监控运行的多个Redis实例。</p><p><img src="https://cdn.jsdelivr.net/gh/konsh/CDN/img/redis-3.png" alt="Sentinel（哨兵）模式"></p><h2 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h2><ul><li>通过发送命令，让Redis服务器返回监控其运行状态，包括主服务器和从服务器；</li><li>当哨兵监测到master宕机，会自动将slave切换成master，然后通过发布订阅模式通知其他的从服务器，修改配置文件，让它们切换主机；</li></ul><p>然而一个哨兵进程对Redis服务器进行监控，也可能会出现问题，为此，我们可以使用多个哨兵进行监控。各个哨兵之间还会进行监控，这样就形成了多哨兵模式。</p><p><img src="https://cdn.jsdelivr.net/gh/konsh/CDN/img/redis-4.png" alt="哨兵模式作用"></p><p>故障切换的过程：<br>    假设主服务器宕机，哨兵1先检测到这个结果，系统并不会马上进行 failover 过程，仅仅是哨兵1主观的认为主服务器不可用，这个现象成为<strong>主观下线</strong>。当后面的哨兵也检测到主服务器不可用，并且数量达到一定值时，那么哨兵之间就会进行一次投票，投票的结果由一个哨兵发起，进行 failover 操作。切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为<strong>客观下线</strong>。这样对于客户端而言，一切都是透明的。</p><h2 id="工作方式"><a href="#工作方式" class="headerlink" title="工作方式"></a>工作方式</h2><ul><li>每个Sentinel（哨兵）进程以每秒钟一次的频率向整个集群中的Master主服务器，Slave从服务器以及其他Sentinel（哨兵）进程发送一个 PING 命令。</li><li>如果一个实例（instance）距离最后一次有效回复 PING 命令的时间超过 down-after-milliseconds 选项所指定的值， 则这个实例会被 Sentinel（哨兵）进程标记为主观下线（SDOWN）。</li><li>如果一个Master主服务器被标记为主观下线（SDOWN），则正在监视这个Master主服务器的所有 Sentinel（哨兵）进程要以每秒一次的频率确认Master主服务器的确进入了主观下线状态。</li><li>当有足够数量的 Sentinel（哨兵）进程（大于等于配置文件指定的值）在指定的时间范围内确认Master主服务器进入了主观下线状态（SDOWN）， 则Master主服务器会被标记为客观下线（ODOWN）。</li><li>在一般情况下， 每个 Sentinel（哨兵）进程会以每 10 秒一次的频率向集群中的所有Master主服务器、Slave从服务器发送 INFO 命令。</li><li>当Master主服务器被 Sentinel（哨兵）进程标记为客观下线（ODOWN）时，Sentinel（哨兵）进程向下线的 Master主服务器的所有 Slave从服务器发送 INFO 命令的频率会从 10 秒一次改为每秒一次。</li><li>若没有足够数量的 Sentinel（哨兵）进程同意 Master主服务器下线， Master主服务器的客观下线状态就会被移除。若 Master主服务器重新向 Sentinel（哨兵）进程发送 PING 命令返回有效回复，Master主服务器的主观下线状态就会被移除。</li></ul><h2 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h2><ul><li>哨兵模式是基于主从模式的，所有主从的优点，哨兵模式都具有。</li><li>主从可以自动切换，系统更健壮，可用性更高（<strong>相当于自动版的主从模式</strong>）。</li></ul><h2 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h2><ul><li>Redis较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。</li></ul><h1 id="Cluster-集群"><a href="#Cluster-集群" class="headerlink" title="Cluster 集群"></a>Cluster 集群</h1><p><strong>Redis 的集群模式本身没有使用一致性 hash 算法，而是使用 slots 插槽。</strong></p><p>Redis 的哨兵模式基本已经可以实现高可用，读写分离 ，但是在这种模式下每台 Redis 服务器都存储相同的数据，很浪费内存，所以在redis3.0上加入了 Cluster 集群模式，实现了 Redis 的分布式存储，也就是说每台 Redis 节点上存储不同的内容。</p><p><img src="https://cdn.jsdelivr.net/gh/konsh/CDN/img/redis-5.webp" alt="Cluster 集群"></p><p>根据官方推荐，集群部署至少要 3 台以上的master节点，最好使用 3 主 3 从六个节点的模式。 </p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li>所有的redis节点彼此互联(PING-PONG机制),内部使用二进制协议优化传输速度和带宽。</li><li>节点的fail是通过集群中超过半数的节点检测失效时才生效。</li><li>客户端与 Redis 节点直连,不需要中间代理层.客户端不需要连接集群所有节点,连接集群中任何一个可用节点即可。</li></ul><h2 id="工作方式-1"><a href="#工作方式-1" class="headerlink" title="工作方式"></a>工作方式</h2><p>在 Redis 的每一个节点上，都有这么两个东西，一个是插槽（slot），它的的取值范围是：0-16383。还有一个就是cluster，可以理解为是一个集群管理的插件。当我们的存取的 Key到达的时候，Redis 会根据 crc16的算法得出一个结果，然后把结果对 16384 求余数，这样每个 key 都会对应一个编号在 0-16383 之间的哈希槽，通过这个值，去找到对应的插槽所对应的节点，然后直接自动跳转到这个对应的节点上进行存取操作。</p><p>为了保证高可用，redis-cluster集群引入了主从模式，一个主节点对应一个或者多个从节点，当主节点宕机的时候，就会启用从节点。当其它主节点ping一个主节点A时，如果半数以上的主节点与A通信超时，那么认为主节点A宕机了。如果主节点A和它的从节点A1都宕机了，那么该集群就无法再提供服务了。dalao</p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 中间件 </tag>
            
            <tag> Database </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo操作</title>
      <link href="//posts/GY3HGT.html"/>
      <url>//posts/GY3HGT.html</url>
      
        <content type="html"><![CDATA[<h1 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h1><p>该文章仅作为记录常用的hexo使用命令，若需从头开始建站请访问<a href="https://hexo.io/zh-cn/docs/">hexo官网文档</a></p><h1 id="操作命令"><a href="#操作命令" class="headerlink" title="操作命令"></a>操作命令</h1><h2 id="新建"><a href="#新建" class="headerlink" title="新建"></a>新建</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure><p>参数说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">-p, —path</td><td style="text-align:center">自定义新文章路径</td></tr><tr><td style="text-align:center">-r, —relpace</td><td style="text-align:center">替换同名文章</td></tr><tr><td style="text-align:center">-s, —slug</td><td style="text-align:center">文章slug，作为新文章的文件名和发布后的URL</td></tr></tbody></table></div><h2 id="生成静态文件"><a href="#生成静态文件" class="headerlink" title="生成静态文件"></a>生成静态文件</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">hexo generate</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可简写为</span></span><br><span class="line">hexo g  </span><br></pre></td></tr></table></figure><p>参数说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">-d, —deploy</td><td style="text-align:center">文件生成后立即部署网站</td></tr><tr><td style="text-align:center">-w, —watch</td><td style="text-align:center">监视文件变动</td></tr><tr><td style="text-align:center">-b, —bail</td><td style="text-align:center">生成过程中若发生任何未处理的异常则抛出异常</td></tr><tr><td style="text-align:center">-f, —force</td><td style="text-align:center">强制重新生成文件<br>Hexo引入了差分机制，若public目录存在，那么hexo g 只会重新生成改动的文件<br>使用该参数的效果相当于 hexo clean &amp;&amp; hexo generate</td></tr><tr><td style="text-align:center">-c, —concurrency</td><td style="text-align:center">最大同时生成文件的数量，默认无限制</td></tr></tbody></table></div><h2 id="发表草稿"><a href="#发表草稿" class="headerlink" title="发表草稿"></a>发表草稿</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">hexo publish [layout] &lt;filename&gt;</span><br></pre></td></tr></table></figure><h2 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">hexo server</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可简写为</span></span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>参数说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">-p, —port</td><td style="text-align:center">重设端口</td></tr><tr><td style="text-align:center">-s, —static</td><td style="text-align:center">只使用静态文件</td></tr><tr><td style="text-align:center">-l, —log</td><td style="text-align:center">启动日志记录，使用覆盖记录格式</td></tr></tbody></table></div><h2 id="部署网站"><a href="#部署网站" class="headerlink" title="部署网站"></a>部署网站</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">hexo deploy</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可简写为</span></span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>参数说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">-g, —generate</td><td style="text-align:center">部署之前预先生成静态文件</td></tr></tbody></table></div><h2 id="清除缓存和静态资源"><a href="#清除缓存和静态资源" class="headerlink" title="清除缓存和静态资源"></a>清除缓存和静态资源</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure><p>清除缓存文件（db.json）和已生成的静态文件（public）</p><p>在某些情况下（特别是更换主题），使用该命令可解决主题不生效问题</p>]]></content>
      
      
      <categories>
          
          <category> 建站 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> 建站 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
